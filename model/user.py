from google.appengine.ext import ndb

import datetime
import random
import math

from model.queue import Queue
from model.connection import Connection

# Represents a user session
#
# This stores the user information / resources / stats for a given user
# during a game
class User(ndb.Model):

    # If the player doesn't specify their name, one will be
    # automatically generated by randomly selecting a first and last
    # name.
    #
    # EG: Pessimistic Wizard, Lazy Student, Incredible Bolt, etc...
    DEFAULT_FIRST_NAMES  = [
        'Red', 'Blue', 'Computer Science', 'Dark', 'Pessimistic',
        'Lazy', 'Yellow', 'Incredible'
    ]
    DEFAULT_SECOND_NAMES = ['Otter', 'Bolt', 'Student', 'Wizard']

    # These are the human readable names for the player's level
    LEVEL_NAMES = [
        "Hamlet", "Village", "Town", "City", "Metropolis", "Magapolis"
    ]

    # The user ID
    uid  = ndb.StringProperty()

    # The user's name (human readable)
    name = ndb.StringProperty()

    # The token which is used by the GAE channel
    secret = ndb.StringProperty()

    # The game this user is a member of
    gid  = ndb.StringProperty()

    # Map of their city
    homeMap = ndb.StringProperty(indexed = False)

    # Which tile their settlement is on
    positionOnMap = ndb.IntegerProperty()

    # The last time their values were updated
    lastUpdated = ndb.DateTimeProperty(auto_now_add=True)

    # What level their city has reached:
    #   0 = Hamlet
    #   1 = Village
    #   2 = Town
    #   3 = City
    #   4 = Metropolis
    #   5 = Magapolis
    level = ndb.IntegerProperty(default=1)

    # How much Gold the user has
    gold = ndb.FloatProperty(default=50)

    # How much Food the user has
    food = ndb.FloatProperty(default=200)

    # How much Wood the user has
    wood = ndb.FloatProperty(default=200)

    # How much Stone the user has
    stone = ndb.FloatProperty(default=200)

    # The level of their home
    administrationLvl = ndb.IntegerProperty(default=1)

    # The number of people at the home
    peopleAtAdministration = ndb.IntegerProperty(default=50)

    # How many houses the player has
    houses = ndb.IntegerProperty(default=1)

    # Has this player got a trade centre?
    trade = ndb.BooleanProperty(default=False)

    # The number of people at the trade centre
    peopleAtTrade = ndb.IntegerProperty(default=0)

    # The number of mills this player has
    mills = ndb.IntegerProperty(default=0)

    # The number of people at the mill
    peopleAtMill = ndb.IntegerProperty(default=0)

    # The level of the mills
    millLvl = ndb.IntegerProperty(default=0)

    # Has this player got storage?
    storage = ndb.BooleanProperty(default=False)

    # The level of the storage
    storageLvl = ndb.IntegerProperty(default=1)

    # Has this player got a military centre?
    military = ndb.BooleanProperty(default=False)

    # The level of the military
    militaryLvl = ndb.IntegerProperty(default=1)

    # Number of people at the military centre
    peopleAtMilitary = ndb.IntegerProperty(default=0)

    # How many mines has this player got?
    mines = ndb.IntegerProperty(default=0)

    # There is a chance that a mine will yield gold. How many gold mines
    # has the user got?
    goldMines = ndb.IntegerProperty(default=0)

    # The level of the mines
    mineLvl = ndb.IntegerProperty(default=1)

    # Number of people at the mines
    peopleAtMine = ndb.IntegerProperty(default=0)

    # How many lumberjacks has this player got?
    lumberjacks = ndb.IntegerProperty(default=0)

    # The level of the lumberjacks
    lumberjackLvl = ndb.IntegerProperty(default=1)

    # Number of people at the lumberjacks
    peopleAtLumberjack = ndb.IntegerProperty(default=0)

    # How many farms has this player got?
    farms = ndb.IntegerProperty(default=0)

    # The level of the farm
    farmLvl = ndb.IntegerProperty(default=1)

    # Number of people at the farm
    peopleAtFarm = ndb.IntegerProperty(default=0)

    # Adds a given queue to this user, and sets its finish time based on
    # this user's lastUpdated time and the given number of seconds
    def addQueue(self, queue, secs):
        queue.finish = self.lastUpdated + datetime.timedelta(seconds = secs)
        queue.uid    = self.uid

    # Calculates the resources up to the finishing point of the given
    # queue, then credits the user with the result of that completed
    # queue
    def finishQueue(self, queue):

        timeDelta = queue.finish - self.lastUpdated
        name      = queue.name
        number    = 1
        self.runUpdate(timeDelta.total_seconds())

        self.lastUpdated = queue.finish

        if queue.queueType == Queue.TYPE_ATTACK:
            self.doAttack(queue)
            return
        elif queue.queueType == Queue.TYPE_RETURN:
            return
        elif queue.queueType == Queue.TYPE_BUILD:
            if name in ['trade', 'storage', 'military', 'grapevine']:
                setattr(self, name, True)
                return
            # Everything else has variable numbers, so get the current
            # number and add one to it
            else:
                name = name + 's'
        elif queue.queueType == Queue.TYPE_LEVEL:
            name = name + 'Lvl'
        elif queue.queueType == Queue.TYPE_PEOPLE:
            name = 'peopleAt' + name.capitalize()

        setattr(self, name, getattr(self, name) + queue.number)


    def doAttack(self, attackQueue):
        enemy = User.query(User.uid == attackQueue.attackTo).fetch()[0]
        enemy.updateValues()

        enemy.peopleAtAdministration = enemy.peopleAtAdministration - ((random.randint(39, 80)/100) * enemy.peopleAtAdministration)
        #Stolen resources
        res = { }
        res["wood"]  = enemy.wood  - (0.05 * enemy.storageLvl) * enemy.wood
        res["gold"]  = enemy.gold  - (0.05 * enemy.storageLvl) * enemy.gold
        res["food"]  = enemy.food  - (0.05 * enemy.storageLvl) * enemy.food
        res["stone"] = enemy.stone - (0.05 * enemy.storageLvl) * enemy.stone

        #Minus the attacked city
        enemy.wood  -= res["wood"]
        enemy.gold  -= res["gold"]
        enemy.food  -= res["food"]
        enemy.stone -= res["stone"]

        queueO          = Queue(queueType = Queue.TYPE_RETURN)
        queueO.attackTo = attackQueue.attackTo
        queueO.number   = attackQueue.number
        queueO.saveResources(res)
        self.addQueue(queueO, 20)
        queueO.put()
        enemy.put()

        Connection.sendMessageTo(enemy, 'attackResult', {
            "text" : "You were attacked",
            "lost" : res
        })
        Connection.sendMessageTo(self,  'attackResult', {
            "text" : "Your attack was successful",
            "gain" : res
        })

    # Recalculates all the resouces since the last update, and sets
    # the last update timestamp to now()
    #
    # If any building / leveling up occured during this time, it will
    # also take that into account. For example, say the user has 1 mine,
    # and was last updated 3 minutes ago, however they were also
    # building a mine, which finished 2 minutes ago. This method will
    # give the user:
    #     (1 minute  of stone as produced by 1 mine)
    #   + (2 minutes of stone as produced by 2 mines)
    #
    # In a more complex example: the user has 1 mine of level 1, and was
    # updated 10 minutes ago. They were leveling up to mines level 2,
    # which finished 7 minutes ago, and buidling a new mine, which
    # finished 1 minute ago. They will get:
    #     (3 minutes of stone as produced by 1 mine,  level 1)
    #   + (6 minutes of stone as produced by 1 mine,  level 2)
    #   + (1 minute  of stone as produced by 2 mines, level 2) 
    def updateValues(self):

        queues = Queue.query(
            Queue.uid == self.uid,
            Queue.finish <= datetime.datetime.now()
        )

        for queue in queues.order(Queue.finish).fetch():
            self.finishQueue(queue)
            queue.key.delete()
        
        # Calculate the change of resources since now and the time we
        # were last updated
        dt = datetime.datetime.now()
        self.runUpdate((dt - self.lastUpdated).total_seconds())

        self.lastUpdated = dt

    # Calculates the resource gains in the given amount of time and adds
    # these to the user's account
    def runUpdate(self, secs):
        self.food +=                                     \
              (self.peopleAtFarm * self.level)           \
            * secs / 60.0
        self.food +=                                     \
              (self.peopleAtMill * self.level)           \
            * secs / 60.0
        self.wood +=                                     \
              self.lumberjackLvl                         \
            * self.peopleAtLumberjack                    \
            * self.lumberjacks                           \
            * secs / 60.0
        self.stone +=                                    \
              self.mineLvl                               \
            * self.peopleAtMine                          \
            * self.mines                                 \
            * secs / 60.0
        self.gold +=                                     \
              self.mineLvl                               \
            * self.peopleAtMine                          \
            * self.goldMines                             \
            * secs / 60.0
        self.gold +=                                     \
              self.peopleAtAdministration                          \
            * 0.1 * (secs / 60.0)

    # Calculates the total number of people this player has
    def totalPeople(self):
        return                                           \
              self.peopleAtAdministration                 \
            + self.peopleAtMine                          \
            + self.peopleAtLumberjack                    \
            + self.peopleAtFarm                          \
            + self.peopleAtMill                          \
            + self.peopleAtTrade                         \
            + self.peopleAtMilitary

    # Calculates the satisfaction rate of this user's city
    def satisfactionRate(self):
        people = self.totalPeople()
        rate   =                                         \
              self.food - 10 * people                    \
            + self.houses * 200 - people                 \
            + 0 - 0

        return 0.0001 * rate

    # Returns true / false depending on whether the user has the given
    # type of building
    def hasBuilding(self, building):
        if building == 'administration' or building == 'home':
            return True
        elif building in ['trade', 'storage', 'military']:
            return getattr(self, building)
        else:
            return bool(getattr(self, building + 's'))

    # Takes a game object as created / returned from the database, and
    # converts it into a dict, with only public facing properties being
    # added
    def toDict(self):
        return {
            "id"    : self.uid,
            "level" : User.LEVEL_NAMES[self.level - 1],
            "position" : self.positionOnMap,
            "resources" : {
                "gold"  : math.floor(self.gold),
                "food"  : math.floor(self.food),
                "wood"  : math.floor(self.wood),
                "stone" : math.floor(self.stone)
            },
            "buildings" : {
                "administration"        : {
                    "num"    : 1,
                    "level"  : self.administrationLvl,
                    "people" : self.peopleAtAdministration
                },
                "house"       : {
                    "num" : self.houses
                },
                "trade"       : {
                    "num"    : 1 if self.trade else 0,
                    "people" : self.peopleAtTrade
                },
                "storage"    : {
                    "num"   : 1 if self.storage else 0,
                    "level" : self.storageLvl
                },
                "military"    : {
                    "num"    : 1 if self.military else 0,
                    "level " : self.militaryLvl,
                    "people" : self.peopleAtMilitary
                },
                "mine"        : {
                    "num"    : self.mines,
                    "level"  : self.mineLvl,
                    "people" : self.peopleAtMine
                },
                "lumberjack"  : {
                    "num"    : self.lumberjacks,
                    "level"  : self.lumberjackLvl,
                    "people" : self.peopleAtLumberjack
                },
                "farm"        : {
                    "num"    : self.farms,
                    "level"  : self.farmLvl,
                    "people" : self.peopleAtFarm
                },
                "mill"        : {
                    "num"    : self.mills,
                    "level"  : self.millLvl,
                    "people" : self.peopleAtMill
                }
            }
        }